import atlas
from genpack import GenPack
import pathlib
import filters
from distutils.dir_util import copy_tree
import os
from path import Path

here = Path(__file__).abspath().dirname()

class CppGenPack(GenPack):
    """ Generate C++ """
    def __init__(self, atlas_system: atlas.AtlasSystem):
        super().__init__(atlas_system)

        # Set up configuration
        script_path = pathlib.Path(__file__).parent.absolute()
        self.template_path = f"{script_path}/templates"
        self.filters = filters.get_filters()

        self.setup()
        pass

    def __repr__(self):
        return f"CppGenPack"

    def __str__(self):
        return self.__repr__()

    def start_generation(self):
        output_folder = "output/cpp"
        gen_output_folder = f"{output_folder}/generated"

        # Prepare general properties
        ctx = self.context.copy()
        self.prepare_system_context(ctx)
        ctx.update({ 'generated_system_folder': gen_output_folder.split('/')[-1]})

        # Copy the handwritten code into the output folder
        self.gen("CMakeLists.common.tpl.txt", f"{output_folder}/CMakeLists.txt", ctx)
        copy_tree(f"{here}/src", f"{output_folder}/src")

        # Generate using the Atlas system
        self.gen("CMakeLists.system.tpl.txt", f"{gen_output_folder}/CMakeLists.txt", ctx)
        for module in self.atlas_system.atlas_modules:
            self.prepare_module_context(module, ctx)
            for interface in module.qface_module.interfaces:
                self.prepare_interface_context(interface, ctx)
                self.gen("Interface.tpl.h", gen_output_folder + "/{{ module_as_folder_path }}/{{ interface.name }}.h", ctx)
                self.gen("Interface.tpl.cpp", gen_output_folder + "/{{ module_as_folder_path }}/{{ interface.name }}.cpp", ctx)
            for struct in module.qface_module.structs:
                self.prepare_struct_context(struct, ctx)
                self.gen("Struct.tpl.h", gen_output_folder + "/{{ module_as_folder_path }}/{{ struct.name }}.h", ctx)
                self.gen("Struct.tpl.cpp", gen_output_folder + "/{{ module_as_folder_path }}/{{ struct.name }}.cpp", ctx)
            for enum in module.qface_module.enums:
                self.prepare_enum_context(enum, ctx)
                self.gen("Enum.tpl.h", gen_output_folder + "/{{ module_as_folder_path }}/{{ enum.name }}.h", ctx)
                self.gen("Enum.tpl.cpp", gen_output_folder + "/{{ module_as_folder_path }}/{{ enum.name }}.cpp", ctx)
        pass

    def finish_generation(self):
        pass

    def clean_context(self, ctx):
        # Clean up properties
        if 'interface' in ctx: ctx.pop('interface')
        if 'struct' in ctx: ctx.pop('struct')
        if 'enum' in ctx: ctx.pop('enum')
        pass

    def prepare_system_context(self, ctx):
        notice = ["", "", "▄▀█ ▀█▀ █░░ ▄▀█ █▀", "█▀█ ░█░ █▄▄ █▀█ ▄█",
        "", "Do not edit, this file is autogenerated", ""]
        ctx.update({'notice_cpp': '\n// '.join(notice).strip()})
        ctx.update({'notice_cmake': '\n# '.join(notice).strip()})

    def prepare_module_context(self, element, ctx):
        ctx.update({'module': element})
        ctx.update({'module_as_folder_path': element.formatted_name('/')})
        ctx.update({'cpp_namespace': element.formatted_name('::')})
        namespace_begin = list()
        for name in element.name_split:
            namespace_begin.append(f"namespace {name} {{")
        ctx.update({'cpp_namespace_begin': '\n'.join(namespace_begin)})
        namespace_end = list()
        for name in reversed(element.name_split):
            namespace_end.append(f"}} // end namespace \"{name}\"")
        ctx.update({'cpp_namespace_end': '\n'.join(namespace_end)})
        pass

    def prepare_interface_context(self, element, ctx):
        self.clean_context(ctx)
        ctx.update({'interface': element})
        pass

    def prepare_struct_context(self, element, ctx):
        self.clean_context(ctx)
        ctx.update({'struct': element})
        pass

    def prepare_enum_context(self, element, ctx):
        self.clean_context(ctx)
        ctx.update({'enum': element})
        pass
